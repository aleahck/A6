open Deck
open Card
open Gamelogic


type player = {
    stake: int;
    mutable cards: card list;
    amount_in: int
  }

let BIG_BLIND= 2

let LITTLE_BLIND=1

type id = int

type move = Call | Raise of int | Check | Fold | Deal

type game= {
    flop: card list;
    bet: int;
    pot: int;
    players: (id * player) list;
    deck: deck;
    first_better: id list;
    last_move: move
  }

let current_player (g:game) = snd (List.hd g.players)

let get_current_id (g:game) = fst (List.hd g.players)

(* Adds 1 card to the flop. *)
let add1_flop (g:game) =
  let d1 = Deck.top_card g.deck in
  let old_flop = g.flop in
  {g with deck = snd d1; flop = old_flop@[fst d1]}

(*[do_player_bet p i] removes [i] from [p]'s stake and adds it to [p]'s
*amount_in. Returns a new, updated player generated by these actions.*)
let do_player_raise (g:game) (p:player) (i: int)=
  let difference= g.bet - p.amount_in in
  {stake= p.stake- (difference+ i);
   cards= p.cards;
   amount_in= p.amount_in + (difference+i)
  }

let do_raise (g:game) (i:int)=
  let new_player= do_player_raise g (current_player g) i in
  let p_id = get_player_id g in
  let new_players= List.tl (g.players)@[(p_id,new_player)] in
  let new_pot= g.pot+ (g.bet-(current_player g).amount_in)+i in
  {flop= g.flop;
   bet= g.bet+i;
   pot= new_pot;
   players= new_players;
   deck= g.deck;
   first_better= g.first_better
  }

let is_valid_bet (i:int) (g:game) =
  if i > (current_player g).stake then false
  else if i < g.bet then false
  else if (* implement blind rules *)
  else return true


let call (g:game) =
  do_raise g 0


let check (g:game) =
  { g with players = (List.tl g.players)@[(get_current_id),(current_player g)] }


(* Helper for fold and dealer. Creates new hand on the turn a player folds. *)
let new_hand (g:game) =
  let fst_player1= snd (List.hd g.players) in
  let fst_player= {fst_player1 with stake=fst_player1.stake-BIG_BLIND}
  let fst_id= fst (List.hd g.players) in
  let snd_player_original = snd (List.nth g.players 1) in
  let snd_id= fst (List.nth g.players 1) in
  let snd_player= snd_player_original with stake=
					     snd_player_original.stake+g.pot in
  let new_start= List.nth g.first_better 1 in
  if (new_start=fst_id) then
    let undelt=
     {flop= [];
     bet=0;
     pot=0;
     players= [(fst_id,fst_player);(snd_id,snd)player)];
     deck= Deck.rand_deck();
     first_better= (List.tl g.first_better)@ [List.hd g.first_better]
  } in deal_two undelt
  else
    let undelt=
    {flop = [];
     bet = 0;
     pot = 0;
     players = [(snd_id,snd_player);(fst_id,fst_player)];
     deck = Deck.rand_deck();
     first_better = (List.tl g.first_better)@[List.hd g.first_better] } in
     deal_two undelt


(* Only works for 2 players; only ends the hand instead of continuing hand
  without player who folded. *)
let fold (g:game) =
  new_hand g


(* Only works for 2 players. For multiple players, must be able to take player
  out of queue and continue game. Also need to work on blinds values. *)
let dealer (g:game) =
  let big = fst (List.hd g.players) in
  let small = fst (List.nth g.first_better 1 in
  if !(List.for_all
    (fun x -> if x = big_blind then x.stake > 2 (* arbitrary *)
      else if x = small_blind then x.stake > 1 (* arbitrary *)
    )
    (g.players)) then None else
  Some (new_hand g)


(* Helper function for new_game. *)
let new_player () =
  {stake = 200; (* arbitrary *)
  cards = (card_of_string "A H", card_of_string "A H");
  amount_in = 0}


(* Only works if Deck.top2_cards returns (card list * deck) *)
let deal_two (g:game) =
  let d1 = Deck.top2_cards g.deck in
  let d2 = Deck.top2_cards (snd d1) in
  let p1 = snd (List.hd g.players) in
  let p2 = snd (List.tl g.players) in
  p1.cards <- Some (fst (d1)) ;
  p2.cards <- Some (fst (d2)) ;
  { g with
    players = [(fst (List.hd g.players), p1) ; (fst (List.tl g.players), p2)] ;
    deck = snd d2 }


(*[deal_two g] takes in a game and returns a pair containing the deck from
*[g] with the first two cards removed and a player, id pair with those two
*cards in the cards field of the player
let deal_two (g:game)
  let this_player=(current_player g with cards=
					  Some (fst (Deck.top2_cards g.deck)) in
  let this_pair=(get_current_id g,this_player) in
  (Deck.top2_cards g.deck, this_pair)
*)


let make_game () =
  let new_player1= new_player () in
  let new_player2= new_player () in
  {flop = [];
  bet = 0;
  pot = 0;
  players = [(1,new_player());(2,new_player())];
  deck = Deck.rand_deck();
  first_better = [1;2] }


(* Turns card list into string. Helper function for to_string functions *)
let rec string_of_clist lst acc =
  match lst with
    | h::[] -> let acc2 = (acc ^ (card_to_string h)) in
      (string_of_clist [] acc2)
    | h::t -> let acc2 = (acc ^ (card_to_string h) ^ ", ") in
      (string_of_clist t acc2)
    | [] -> acc

(* Turns player list into string.
* Only prints out the player IDs (i.e. "Player 1, Player 2, Player 3")
* Helper function for to_string functions. *)
let rec string_of_plist lst acc =
  match lst with
    | h::[] -> let acc2 = acc ^ "Player " ^ (string_of_int (fst h)) in
      (string_of_plist [] acc2)
    | h::t -> let acc2 = acc ^ "Player " ^ (string_of_int (fst h)) ^ ", " in
      (string_of_plist t acc2)
    | [] -> acc


let game_to_string (g:game) =
  "The flop is: " ^ (string_of_clist g.flop "") ^ "\n" ^
  "The bet is: " ^ (string_of_int g.bet) ^ "\n" ^
  "The pot is: " ^ (string_of_int g.pot) ^ "\n"


let player_to_string (p:player) =
  "Your stake is: " ^ (string_of_int p.stake) ^ "\n" ^
  "Your cards are: " ^ (string_of_clist p.cards) ^ "\n" ^
  "You have bet: " ^ (string_of_int p.amount_n) ^ "\n"

